import
    asyncdispatch,
    asynchttpserver,
    mimetypes,
    nativesockets,
    os,
    random,
    sequtils,
    strutils,
    tables,
    times,
    uri,
    zippy

from httpcore import
    HttpMethod,
    HttpHeaders

from quotes import quotes
from titles import titles, chyrons

type
    HttpResponse = tuple[
        code: HttpCode,
        content: string,
        headers: seq[(string, string)]]

    Settings = ref object
        mimes: MimeDB
        port: Port
        title: string
        address: string
        name: string
        version: string
        domain: Domain
        printLogging: bool

    TemplateData = ref object
        htmlContentHeader: seq[(string, string)]
        pageTitle: string
        canonicalLink: string
        chyron: string
        content: string
        quote: tuple[
            quote: string,
            author: string,
            citation: string]

    RouteHandler = proc(req: Request): Future[void] {.gcsafe.}
    RouteTable = Table[string, RouteHandler]

proc newRouter: ref RouteTable = 
    new(result)
    return result

#-- Compile time behavior
proc slurpStaticFiles: Table[string, string] =
    result = initTable[string, string]()
    for entry in walkDirRec("static", {pcFile, pcDir}):
        if dirExists(entry):
            continue
        result[entry] = staticRead(entry)

proc slurpLayouts: Table[string, string] =
    result = initTable[string, string]()
    var layouts = initTable[string, string]()
    var included_content = initTable[string, string]()

    for entry in walkDirRec("layouts", {pcDir}):
        for entry2 in walkDirRec(entry, {pcDir, pcFile}):
            if dirExists(entry2):
                continue
            included_content[entry2] = staticRead(entry2)

    for entry in walkDirRec("layouts", {pcFile}):
        if included_content.hasKey(entry):
            continue
        layouts[entry] = staticRead(entry)

    for layout, layout_content in layouts.mpairs():
        result[layout] = layout_content
        for incl_file in included_content.keys():
            echo layout
            result[layout] = result[layout].replace("{{#" & incl_file & "}}", included_content[incl_file])

proc slurpDynamicFiles: Table[string, string] =
    result = initTable[string, string]()
    for entry in walkDirRec("dynamic", {pcFile}):
        let contents = staticRead(entry)
        result[entry] = contents
        result[entry.splitFile[1]] = contents

const STATIC_FILES = slurpStaticFiles()
const LAYOUTS = slurpLayouts()
const DYNAMIC_FILES = slurpDynamicFiles()
const GEN_STRING = "Generated by <a target=\"_blank\" href=\"https://github.com/killerbat00/bhm.sh\">my custom webserver</a> written in <a href='https://nim-lang.org'>Nim</a> in $1 ms"
const MAIN_TEMPLATE = "layouts/main.bhml"
#-- End compile time behavior

proc render(originalFile: string, replacements: varargs[(string, string)]): string =
    return originalFile.multiReplace(replacements)

proc sendTemplatedFile(data: TemplateData, reqTime: float): HttpResponse =
    var rendered = render(LAYOUTS[MAIN_TEMPLATE], @[
        ("{{#pageTitle}}", "Brian's " & data.pageTitle),
        ("{{#canonicalLink}}", data.canonicalLink),
        ("{{#chyron}}", data.chyron),
        ("{{#content}}", data.content)
    ])

    let
        timeTaken = (cpuTime() - reqTime) * 1000
        finalContent = rendered.replace("{{#generationString}}", GEN_STRING % $timeTaken.formatFloat(ffDecimal, 5))

    return (code: Http200, content: finalContent, headers: data.htmlContentHeader)

proc sendTemplatedFile(settings: Settings, req: Request, route: seq[string], data: TemplateData): HttpResponse =
    let
        url = route[0]
        reqTime = cpuTime()

    if (req.url.query.len > 0) or (route.len > 1):
        return (code: Http301, content: "", headers: @[("Location", "/" & url)])

    data.canonicalLink = "<link rel=\"canonical\" href=\"http://bhm.sh/" & url & "\">"
    data.content = DYNAMIC_FILES[url]

    return sendTemplatedFile(data, reqTime)

proc index(settings: Settings, req: Request, data: TemplateData, route: seq[string]): HttpResponse =
    var indexRedirectResult = (code: Http301, content: "", headers: @[(
            "Location", "/")])
    if (req.url.query.len > 0) or (route.len > 1):
        return indexRedirectResult

    let reqTime = cpuTime()
    data.canonicalLink = "<link rel=\"canonical\" href=\"http://bhm.sh/\">"
    data.content = render(DYNAMIC_FILES["index"], @[
        ("{{#quoteText}}", data.quote.quote),
        ("{{#quoteAuthor}}", data.quote.author),
        ("{{#quoteCitation}}", data.quote.citation)
    ])

    return sendTemplatedFile(data, reqTime)

proc sendStaticFile(settings: Settings, req: Request): HttpResponse =
    let
        url = req.url.path[1 .. ^1]
        ext = url.splitFile.ext
        file = STATIC_FILES[url]
    var mimetype = settings.mimes.getMimetype(ext.toLowerAscii)

    if (mimetype == "application/x-navimap"):
        mimetype = "application/json"

    return (code: Http200, content: file, headers: @[("Content-Type", mimetype)])

proc printReqInfo(settings: Settings, req: Request) =
    if settings.printLogging:
        echo getTime().local, " - ", req.hostname, " ", req.reqMethod, " ",
                req.url.path, " ", req.url.query

proc genMsg(settings: Settings): string =
    let url = "http://$1:$2/" % [settings.address, $settings.port.int]
    let t = now()
    let pid = getCurrentProcessId()
    result = """$1 v$2
Address:      $3
Current Time: $4
PID:          $5""" % [settings.name, settings.version, url, $t, $pid]

proc logException(settings: Settings) =
    let
        e = getCurrentException()
        msg = getCurrentExceptionMsg()
    echo repr(e), "\n", repr(msg)
    writeStackTrace()

proc serve(settings: Settings, routes: ref RouteTable) =
    echo genMsg(settings)
    let
        htmlContentHeader = @[("Content-Type", "text/html"), ("Content-Language", "en-US")]
        server = newAsyncHttpServer()

    proc handleRequest(req: Request): Future[void] {.async, gcsafe.} =
        var res: HttpResponse
        var data = TemplateData(pageTitle: sample(titles.titles), chyron: sample(titles.chyrons), quote: sample(quotes.quotes), htmlContentHeader: htmlContentHeader)

        try:
            when not defined(release):
                printReqInfo(settings, req)
            # ignore QSP
            if req.url.query.len > 0:
                await req.respond(Http500, "", @[].newHttpHeaders)
                return

            let path = req.url.path[1 .. ^1]
            let route = toSeq(req.url.path.split("/"))[1 .. ^1] #always starts with `/`; discard first item

            if (path in STATIC_FILES):
                res = sendStaticFile(settings, req)
            elif (route[0] in routes):
                await routes[route[0]](req)
                return
            elif (route[0] in DYNAMIC_FILES):
                res = sendTemplatedFile(settings, req, route, data)
                await req.respond(res.code, res.content, res.headers.newHttpHeaders)
                return

            else:
                res = sendTemplatedFile(settings, req, @["404"], data)

        except:
            logException(settings)
            res = (code: Http500, content: "", headers: @[])

        if res.code == Http200 and req.headers.hasKey("Accept-Encoding") and req.headers["Accept-Encoding"].contains("gzip"):
            res.headers.add(("Content-Encoding", "gzip"))
            let content = compress(res.content, BestSpeed)
            await req.respond(res.code, content, res.headers.newHttpHeaders)
        else:
            await req.respond(res.code, res.content, res.headers.newHttpHeaders)

    asyncCheck server.serve(settings.port, handleRequest, settings.address, -1, settings.domain)

proc handleCtrlC() {.noconv.} =
    echo "\nExiting..."
    quit()

setControlCHook(handleCtrlC)

when isMainModule:
    let settings = Settings(
        mimes: newMimetypes(),
        port: Port(1992),
        title: "bhm.sh",
        address: "0.0.0.0",
        name: "bhm.sh",
        version: "0.7",
        domain: AF_INET,
        printLogging: false,
    )

    when not defined(release):
        settings.printLogging = true

    var addrInfo = getAddrInfo(settings.address, settings.port, settings.domain)
    if addrInfo == nil:
        echo "Error: Could not resolve address '" & settings.address & "'."
        quit(1)

    proc index(req: Request): Future[void] {.gcsafe.} =
        let route = toSeq(req.url.path.split("/"))[1 .. ^1] #always starts with `/`; discard first item

        # ignore QSP and .html
        if (route.len > 1):
            return req.respond(Http301, "", @[("Location", "/")].newHttpHeaders)

        let 
            reqTime = cpuTime()
            htmlContentHeader = @[("Content-Type", "text/html"), ("Content-Language", "en-US")]
            data = TemplateData(pageTitle: sample(titles.titles), chyron: sample(titles.chyrons), quote: sample(quotes.quotes), htmlContentHeader: htmlContentHeader)

        data.canonicalLink = "<link rel=\"canonical\" href=\"http://bhm.sh/\">"
        data.content = render(DYNAMIC_FILES["index"], @[
            ("{{#quoteText}}", data.quote.quote),
            ("{{#quoteAuthor}}", data.quote.author),
            ("{{#quoteCitation}}", data.quote.citation)
        ])

        let response = sendTemplatedFile(data, reqTime)
        return req.respond(response.code, response.content, response.headers.newHttpHeaders)

    randomize()
    let routes = new(RouteTable)
    routes[""] = index
    routes["/"] = index
    routes["index"] = index
    routes["index.html"] = index
    serve(settings, routes)
    runForever()
