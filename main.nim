import 
    asyncdispatch,
    asynchttpserver, 
    mimetypes, 
    nativesockets,
    os,
    random,
    sequtils,
    strutils,
    times, 
    uri,
    tables

from httpcore import HttpMethod, HttpHeaders

type 
    HttpResponse = tuple[
        code: HttpCode,
        content: string,
        headers: HttpHeaders]

    Settings = object
        mimes: MimeDB
        port: Port
        title: string
        address: string
        name: string
        version: string
        files: Table[string, string]
        domain: Domain
        printLogging: bool

    TemplateData = ref object
        pageTitle: string
        canonicalLink: string
        chyron: string
        content: string

const validDirs = ["static/fonts", "static/js", "static/styles", "static/templates"]

# gzip/brotli the files eventually - that'd be cool
proc slurpFiles(): Table[string, string] =
    result = initTable[string, string]()
    for dir in walkDirRec("static", {pcDir}):
        if not (dir in validDirs):
            continue

        let public_dir = dir == "static/templates"
        for file in walkDirRec(dir):
            var contents = staticRead(file)
            if public_dir:
                result[file.splitFile[1]] = contents
            else:
                result[file] = contents

const files = slurpFiles()
const titles = ["cabin in the woods", "slice of the internet", "home on the World Wide Web", "bytes", "virtual space", "website", "page", "country corner", "internet of things", "is the place to be", "personal digital destination", "home for wayward dogs", "home of horrors (NOT scary)"]
const chyrons = ["Now in technicolor", "...oh, this is still here?", "fueled by Diet Mtn Dew", "allegedly", "dog hair now included!", "enjoy your stay!", "FREE bits AND bytes!"]

proc render(originalFile: string, replacements: varargs[(string, string)]): string =
    return originalFile.multiReplace(replacements)

proc sendTemplatedFile(settings: Settings, req: Request, route: seq[string], data: TemplateData, headers: HttpHeaders): HttpResponse =
    let url = route[0]

    if (req.url.query.len > 0) or (route.len > 1):
        return (code: Http301, content: "", headers: {"Location": "/" & url}.newHttpHeaders)

    let 
        reqTime = cpuTime()
        layoutFile = settings.files["static/layouts/mainTemplate.html"]

    data.canonicalLink = "<link rel=\"canonical\" href=\"http://bhm.sh/" & url & "\">"
    data.content = settings.files[url]
    
    var rendered = render(layoutFile, @[
        ("{{#pageTitle}}", "Brian's " & data.pageTitle),
        ("{{#canonicalLink}}", data.canonicalLink),
        ("{{#chyron}}", data.chyron),
        ("{{#content}}", data.content)
    ])

    let 
        timeTaken = (cpuTime() - reqTime) * 1000
        finalContent = rendered.replace("{{#generationString}}", "Generated by my custom webserver written in <a href='https://nim-lang.org'>Nim</a> in " & $timeTaken.formatFloat(ffDecimal, 5) & "ms")
    
    return (code: Http200, content: finalContent, headers: headers)

proc sendStaticFile(settings: Settings, req: Request): HttpResponse =
    let 
        url = req.url.path
        ext = url.splitFile.ext
        mimetype = settings.mimes.getMimetype(ext.toLowerAscii)
        file = settings.files[url[1 .. ^1]]

    return (code: Http200, content: file, headers: {"Content-Type": mimetype}.newHttpHeaders)

proc index(settings: Settings, req: Request, data: TemplateData, route: seq[string], headers: HttpHeaders): HttpResponse =
    let redirectResult = (code: Http301, content: "", headers: {"Location": "/"}.newHttpHeaders)
    if (req.url.query.len > 0) or (route.len > 1):
        return redirectResult

    return sendTemplatedFile(settings, req, @["index"], data, headers)

proc printReqInfo(settings: Settings, req: Request) =
    if settings.printLogging:
        echo getTime().local, " - ", req.hostname, " ", req.reqMethod, " ", req.url.path, " ", req.url.query

proc handleCtrlC() {.noconv.} =
    echo "\nExiting..."
    quit()

setControlCHook(handleCtrlC)

proc genMsg(settings: Settings): string =
    let url = "http://$1:$2/" % [settings.address, $settings.port.int]
    let t = now()
    let pid = getCurrentProcessId()
    result = """$1 v$2
Address:      $3 
Current Time: $4
PID:          $5""" % [settings.name, settings.version, url, $t, $pid]

proc send500(): HttpResponse =
    return (code: Http500, content: "", headers: nil)

proc logException(settings: Settings) =
    if not settings.printLogging:
        return

    let
        e = getCurrentException()
        msg = getCurrentExceptionMsg()
    echo repr(e), "\n", repr(msg)
    writeStackTrace()

proc serve*(settings: Settings) =
    var server = newAsyncHttpServer()
    echo genMsg(settings)

    proc handleRequest(req: Request): Future[void] {.async.} =
        var res: HttpResponse
        var data = TemplateData(pageTitle: sample(titles), chyron: sample(chyrons))
        let htmlContentHeader = {"Content-Type": "text/html"}.newHttpHeaders

        try:
            printReqInfo(settings, req)
            let route = toSeq(req.url.path.split("/"))[1 .. ^1]

            if (route.len < 1) or (route[0] == "") or (route[0] == "index"):
                res = index(settings, req, data, route, htmlContentHeader)

            elif (route[0] in settings.files):
                res = sendTemplatedFile(settings, req, route, data, htmlContentHeader)

            elif (req.url.path in settings.files):
                res = sendStaticFile(settings, req)

            else:
                res = sendTemplatedFile(settings, req, @["404"], data, htmlContentHeader)

        except:
            logException(settings)
            res = send500()
        await req.respond(res.code, res.content, res.headers)

    asyncCheck server.serve(settings.port, handleRequest, settings.address, -1, settings.domain)

when isMainModule:
    let settings = Settings(
        mimes: newMimetypes(),
        port: Port(1992),
        title: "bhm.sh",
        address: "0.0.0.0",
        name: "bhm.sh",
        version: "0.1",
        files: files,
        domain: AF_INET,
        printLogging: true,
    )

    var addrInfo = getAddrInfo(settings.address, settings.port, settings.domain)
    if addrInfo == nil:
        echo "Error: Could not resolve address '" & settings.address & "'."
        quit(1)

    randomize()
    serve(settings)
    runForever()